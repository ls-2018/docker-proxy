// Code generated by bpf2go; DO NOT EDIT.
//go:build mips || mips64 || ppc64 || s390x

package tc_proxy

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"
	"structs"

	"github.com/cilium/ebpf"
)

type tc_proxyConnectionInfo struct {
	_               structs.HostLayout
	OriginalDstIp   uint32
	OriginalDstPort uint16
	OriginalSrcIp   uint32
	OriginalSrcPort uint16
}

type tc_proxyProxyRedirectConfig struct {
	_       structs.HostLayout
	Addr    uint32
	Port    uint16
	Ifindex uint16
	Mac     [6]uint8
	_       [2]byte
}

// loadTc_proxy returns the embedded CollectionSpec for tc_proxy.
func loadTc_proxy() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_Tc_proxyBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load tc_proxy: %w", err)
	}

	return spec, err
}

// loadTc_proxyObjects loads tc_proxy and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*tc_proxyObjects
//	*tc_proxyPrograms
//	*tc_proxyMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadTc_proxyObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadTc_proxy()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// tc_proxySpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tc_proxySpecs struct {
	tc_proxyProgramSpecs
	tc_proxyMapSpecs
	tc_proxyVariableSpecs
}

// tc_proxyProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tc_proxyProgramSpecs struct {
	ProxyEgress *ebpf.ProgramSpec `ebpf:"proxy_egress"`
	RawEgress   *ebpf.ProgramSpec `ebpf:"raw_egress"`
}

// tc_proxyMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tc_proxyMapSpecs struct {
	ConnectionMap *ebpf.MapSpec `ebpf:"connection_map"`
	IpTtl         *ebpf.MapSpec `ebpf:"ip_ttl"`
	RedirectMap   *ebpf.MapSpec `ebpf:"redirect_map"`
}

// tc_proxyVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type tc_proxyVariableSpecs struct {
}

// tc_proxyObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadTc_proxyObjects or ebpf.CollectionSpec.LoadAndAssign.
type tc_proxyObjects struct {
	tc_proxyPrograms
	tc_proxyMaps
	tc_proxyVariables
}

func (o *tc_proxyObjects) Close() error {
	return _Tc_proxyClose(
		&o.tc_proxyPrograms,
		&o.tc_proxyMaps,
	)
}

// tc_proxyMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadTc_proxyObjects or ebpf.CollectionSpec.LoadAndAssign.
type tc_proxyMaps struct {
	ConnectionMap *ebpf.Map `ebpf:"connection_map"`
	IpTtl         *ebpf.Map `ebpf:"ip_ttl"`
	RedirectMap   *ebpf.Map `ebpf:"redirect_map"`
}

func (m *tc_proxyMaps) Close() error {
	return _Tc_proxyClose(
		m.ConnectionMap,
		m.IpTtl,
		m.RedirectMap,
	)
}

// tc_proxyVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadTc_proxyObjects or ebpf.CollectionSpec.LoadAndAssign.
type tc_proxyVariables struct {
}

// tc_proxyPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadTc_proxyObjects or ebpf.CollectionSpec.LoadAndAssign.
type tc_proxyPrograms struct {
	ProxyEgress *ebpf.Program `ebpf:"proxy_egress"`
	RawEgress   *ebpf.Program `ebpf:"raw_egress"`
}

func (p *tc_proxyPrograms) Close() error {
	return _Tc_proxyClose(
		p.ProxyEgress,
		p.RawEgress,
	)
}

func _Tc_proxyClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed tc_proxy_bpfeb.o
var _Tc_proxyBytes []byte
