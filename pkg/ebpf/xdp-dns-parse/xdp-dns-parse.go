package tc_dns_parse

import (
	"bytes"
	"context"
	"docker-proxy/pkg/cfg"
	"docker-proxy/pkg/log"
	"docker-proxy/pkg/utils"
	"encoding/binary"
	"errors"
	"fmt"
	"io/ioutil"
	"strconv"
	"strings"
	"time"
	"unsafe"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
)

//go:generate go run -mod=vendor github.com/cilium/ebpf/cmd/bpf2go -type dns_question -type cache_record -type dns_peer xdp_dns_parse ../../../ebpf/xdp-dns-parse.bpf.c -- -D${TARGET_ARCH} -I./../../../ebpf/headers -Wall -Wno-unused-variable  -Wno-unused-function

func Load(ctx context.Context, opt cfg.Options, successCallBack func()) {
	log.L.Println("✈️ cat /sys/kernel/debug/tracing/trace_pipe")
	obj := xdp_dns_parseObjects{}
	err := loadXdp_dns_parseObjects(&obj, &ebpf.CollectionOptions{
		Programs: ebpf.ProgramOptions{
			LogLevel:     ebpf.LogLevelInstruction | ebpf.LogLevelBranch | ebpf.LogLevelStats,
			LogSizeStart: 8 * 1024 * 1024 * 10,
			LogDisabled:  false,
		},
		Maps: ebpf.MapOptions{
			PinPath: opt.PinPath,
		},
	})
	if err != nil {
		var ve *ebpf.VerifierError
		if errors.As(err, &ve) {
			log.L.Fatalf("Failed to load bpf obj: %v\n%+v", err, ve)
		}
		log.L.Fatalf("Failed to load bpf obj: %v", err)
	}

	_, _, _, index := utils.GetLocalIP()
	tcx, err := link.AttachXDP(link.XDPOptions{
		Interface: index,
		Program:   obj.xdp_dns_parsePrograms.XdpParseDnsA,
	})
	if err != nil {
		panic(err)
	}
	for _, domain := range opt.Domains {
		key := getKey(domain)
		obj.xdp_dns_parseMaps.DnsA_cache.Update(&key, &xdp_dns_parseCacheRecord{}, ebpf.UpdateAny)
	}
	rd, err := ringbuf.NewReader(obj.Events)
	if err != nil {
		log.L.Fatalf("opening ringbuf reader: %s", err)
	}

	go func() {
		log.L.Println("Waiting for events..")

		// bpfEvent is generated by bpf2go.
		var event xdp_dns_parseDnsPeer

		for {
			record, err := rd.Read()
			if err != nil {
				if errors.Is(err, ringbuf.ErrClosed) {
					log.L.Println("Received signal, exiting..")
					return
				}
				log.L.Printf("reading from reader: %s", err)
				continue
			}

			// Parse the ringbuf event entry into a bpfEvent structure.
			if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &event); err != nil {
				log.L.Printf("parsing ringbuf event: %s", err)
				continue
			}
			for i, ip := range event.Ip {
				if ip == 0 {
					continue
				}
				log.L.Printf("type:%d class:%d domain:%s ip:%s ttl:%d", event.Dq.RecordType, event.Dq.Class, utils.DecodeDNSName(event.Dq.Name[:]), utils.U32ToIP(ip), event.Ttl[i])
			}
		}
	}()

	go Clean(ctx, obj.IpTtl)
	successCallBack()
	select {
	case <-ctx.Done():
		if err := rd.Close(); err != nil {
			log.L.Fatalf("closing ringbuf reader: %s", err)
		}
		tcx.Close()
	}
}

func getKey(host string) xdp_dns_parseDnsQuestion {
	queryKey := xdp_dns_parseDnsQuestion{
		RecordType: 1,
		Class:      1,
	}
	nameSlice := make([]byte, 256)
	copy(nameSlice, host)
	dnsName := utils.ReplaceDotsWithLengthOctets(nameSlice)

	for i, v := range dnsName {
		if i+1 <= len(queryKey.Name) {
			queryKey.Name[i] = v
		}
	}
	return queryKey
}
func getUptimeFromProc() (time.Duration, error) {
	data, err := ioutil.ReadFile("/proc/uptime")
	if err != nil {
		return 0, err
	}

	fields := strings.Fields(string(data))
	if len(fields) < 1 {
		return 0, fmt.Errorf("invalid uptime data")
	}

	secs, err := strconv.ParseFloat(fields[0], 64)
	if err != nil {
		return 0, err
	}
	return time.Duration(secs * float64(time.Second)), nil
}

func Clean(ctx context.Context, ttl *ebpf.Map) {
	ticker := time.NewTicker(5 * time.Second)
	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			proc, err := getUptimeFromProc()
			if err != nil {
				log.L.Printf("Failed to get uptime: %v", err)
				time.Sleep(5 * time.Second)
				continue
			}
			var key, value uint32
			var keys []uint32

			iter := ttl.Iterate()
			for iter.Next(&key, &value) {
				if value < uint32(proc/time.Second) {
					keys = append(keys, key)
				}
			}
			if err := iter.Err(); err != nil {
				log.L.Fatalf("迭代过程中发生错误: %v", err)
			}
			for _, key := range keys {
				log.L.Printf("Deleting ip_ttl map key: %d", key)
				ttl.Delete(unsafe.Pointer(&key))
			}
			ticker.Reset(5 * time.Second)
		default:
		}
	}
}

//tc qdisc  delete dev eth0 clsact
//tc qdisc  add    dev eth0 clsact
//tc filter add    dev eth0 ingress bpf obj tc_dns_parse_bpfel.o sec 'classifier/ingress' > a.txt 2>&1
//tc filter show   dev eth0 ingress
